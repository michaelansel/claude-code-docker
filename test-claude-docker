#!/usr/bin/env bash
# Tests for claude-docker — exercises argument parsing, agent lookup, and
# command construction without actually running containers.
set -euo pipefail

PASS=0
FAIL=0
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
UNDER_TEST="$SCRIPT_DIR/claude-docker"

# --- helpers ---

current_build_hash() {
    cat "$SCRIPT_DIR/Dockerfile" "$SCRIPT_DIR/entrypoint.sh" | shasum -a 256 | cut -d' ' -f1
}

# Write a runtime stub (docker/finch) to $TEST_DIR with given body.
# Usage: write_rt_stub <body>
# Writes the same stub as both $TEST_DIR/docker and $TEST_DIR/finch.
write_rt_stubs() {
    local body="$1"
    for rt in docker finch; do
        echo "$body" > "$TEST_DIR/$rt"
        chmod +x "$TEST_DIR/$rt"
    done
}

setup() {
    TEST_DIR=$(mktemp -d)
    # Fake credentials so the script doesn't bail early
    mkdir -p "$TEST_DIR/.claude"
    echo '{}' > "$TEST_DIR/.claude/.credentials.json"
    mkdir -p "$TEST_DIR/.claude-docker"
    # Copy agents.yaml into the fake config dir
    cp "$SCRIPT_DIR/agents.yaml.example" "$TEST_DIR/.claude-docker/agents.yaml"
    # Compute expected hash so the default stub returns a matching hash
    local expected_hash
    expected_hash=$(current_build_hash)
    # Fake container runtime stubs that log the command they would run
    write_rt_stubs "$(cat <<STUB
#!/usr/bin/env bash
if [[ "\${1:-}" == "image" && "\$*" == *"--format"* ]]; then echo "$expected_hash"; exit 0; fi
if [[ "\${1:-}" == "image" ]]; then exit 0; fi
if [[ "\${1:-}" == "stop" ]]; then exit 0; fi
echo "RT_ARGS: \$*"
STUB
)"
    # Fake format-stream
    cat > "$TEST_DIR/format-stream" <<'STUB'
#!/usr/bin/env bash
cat
STUB
    chmod +x "$TEST_DIR/format-stream"
    export PATH="$TEST_DIR:$PATH"
    export HOME="$TEST_DIR"
    export TEST_DIR="$TEST_DIR"
}

teardown() {
    rm -rf "$TEST_DIR"
}

assert_eq() {
    local label="$1" expected="$2" actual="$3"
    if [[ "$expected" == "$actual" ]]; then
        echo "  PASS: $label"
        PASS=$((PASS + 1))
    else
        echo "  FAIL: $label"
        echo "    expected: $expected"
        echo "    actual:   $actual"
        FAIL=$((FAIL + 1))
    fi
}

assert_contains() {
    local label="$1" needle="$2" haystack="$3"
    if [[ "$haystack" == *"$needle"* ]]; then
        echo "  PASS: $label"
        PASS=$((PASS + 1))
    else
        echo "  FAIL: $label"
        echo "    expected to contain: $needle"
        echo "    actual:              $haystack"
        FAIL=$((FAIL + 1))
    fi
}

assert_not_contains() {
    local label="$1" needle="$2" haystack="$3"
    if [[ "$haystack" != *"$needle"* ]]; then
        echo "  PASS: $label"
        PASS=$((PASS + 1))
    else
        echo "  FAIL: $label"
        echo "    expected NOT to contain: $needle"
        echo "    actual:                  $haystack"
        FAIL=$((FAIL + 1))
    fi
}

assert_exit() {
    local label="$1" expected="$2" actual="$3"
    if [[ "$expected" -eq "$actual" ]]; then
        echo "  PASS: $label"
        PASS=$((PASS + 1))
    else
        echo "  FAIL: $label (exit $actual, expected $expected)"
        FAIL=$((FAIL + 1))
    fi
}

# --- tests ---

echo "=== agent list ==="
setup
out=$(bash "$UNDER_TEST" agent list 2>&1)
assert_contains "shows notes agent" "notes" "$out"
assert_contains "shows directory" "~/Documents/Notes" "$out"
teardown

echo "=== agent unknown ==="
setup
rc=0
out=$(bash "$UNDER_TEST" agent nonexistent 2>&1) || rc=$?
# Python implementation returns exit code 2 for invalid agent command
assert_exit "exits non-zero" 2 "$rc"
assert_contains "error message" "invalid choice" "$out"
assert_contains "shows available commands" "list" "$out"
teardown

echo "=== agent with no name ==="
setup
rc=0
out=$(bash "$UNDER_TEST" agent 2>&1) || rc=$?
# Python implementation returns exit code 2 for missing agent subcommand
assert_exit "exits non-zero" 2 "$rc"
assert_contains "error message" "usage:" "$out"
teardown

echo "=== no arguments shows usage ==="
setup
rc=0
out=$(bash "$UNDER_TEST" 2>&1) || rc=$?
assert_exit "exits non-zero" 2 "$rc"
assert_contains "shows usage" "claude-docker" "$out"
teardown

echo "=== direct prompt requires -p flag ==="
setup
out=$(bash "$UNDER_TEST" -p "hello world" 2>&1)
assert_contains "prompt in runtime args" "hello world" "$out"
teardown

echo "=== help flag ==="
setup
out=$(bash "$UNDER_TEST" -h 2>&1)
assert_contains "shows agent usage" "agent <name>" "$out"
assert_contains "shows --no-stream" "--no-stream" "$out"
# Check for Usage: (uppercase U) at the start of help output
assert_contains "shows Usage:" "Usage:" "$out"
teardown

echo "=== direct prompt passes through ==="
setup
out=$(bash "$UNDER_TEST" -p "hello world" 2>&1)
assert_contains "prompt in runtime args" "hello world" "$out"
teardown

echo "=== direct prompt with -s streams ==="
setup
out=$(bash "$UNDER_TEST" -s -p "hello" 2>&1)
assert_contains "uses stream-json" "stream-json" "$out"
teardown

echo "=== agent mode sets /c3po auto ==="
setup
mkdir -p "$TEST_DIR/Documents/Notes"
out=$(bash "$UNDER_TEST" agent notes 2>&1)
assert_contains "prompt is /c3po auto" "/c3po auto" "$out"
teardown

echo "=== agent mode streams by default ==="
setup
mkdir -p "$TEST_DIR/Documents/Notes"
out=$(bash "$UNDER_TEST" agent notes 2>&1)
assert_contains "uses stream-json" "stream-json" "$out"
teardown

echo "=== agent mode --no-stream disables streaming ==="
setup
mkdir -p "$TEST_DIR/Documents/Notes"
out=$(bash "$UNDER_TEST" agent --no-stream notes 2>&1)
assert_contains "prompt is /c3po auto" "/c3po auto" "$out"
# Should NOT have stream-json since --no-stream was passed
if [[ "$out" != *"stream-json"* ]]; then
    echo "  PASS: no stream-json flag"
    PASS=$((PASS + 1))
else
    echo "  FAIL: stream-json should not be present with --no-stream"
    FAIL=$((FAIL + 1))
fi
teardown

echo "=== flags before agent subcommand ==="
setup
mkdir -p "$TEST_DIR/Documents/Notes"
out=$(bash "$UNDER_TEST" -sj agent notes 2>&1)
assert_contains "uses stream-json" "stream-json" "$out"
assert_contains "prompt is /c3po auto" "/c3po auto" "$out"
teardown

echo "=== container gets a --name ==="
setup
mkdir -p "$TEST_DIR/Documents/Notes"
out=$(bash "$UNDER_TEST" agent --no-stream notes 2>&1)
assert_contains "has --name flag" "--name claude-code-" "$out"
teardown

echo "=== agent mode sets CLAUDE_PROJECT_NAME to agent name ==="
setup
mkdir -p "$TEST_DIR/Documents/Notes"
out=$(bash "$UNDER_TEST" agent --no-stream notes 2>&1)
assert_contains "env has CLAUDE_PROJECT_NAME=notes" "CLAUDE_PROJECT_NAME=notes" "$out"
teardown

echo "=== direct mode sets CLAUDE_PROJECT_NAME to dir basename ==="
setup
out=$(bash "$UNDER_TEST" -d /tmp -p "hello" 2>&1)
assert_contains "env has CLAUDE_PROJECT_NAME=tmp" "CLAUDE_PROJECT_NAME=tmp" "$out"
teardown

echo "=== token env var passes through ==="
setup
# Remove credentials file so we rely on env var
rm -f "$TEST_DIR/.claude/.credentials.json"
out=$(CLAUDE_CODE_OAUTH_TOKEN="test-token-123" bash "$UNDER_TEST" -p "hello" 2>&1)
assert_contains "env has CLAUDE_CODE_OAUTH_TOKEN" "CLAUDE_CODE_OAUTH_TOKEN=test-token-123" "$out"
assert_not_contains "no credentials mount" ".credentials.json:ro" "$out"
teardown

echo "=== token file is read ==="
setup
# Remove credentials file so we rely on token file
rm -f "$TEST_DIR/.claude/.credentials.json"
echo "file-token-456" > "$TEST_DIR/.claude-docker/.oauth-token"
out=$(bash "$UNDER_TEST" -p "hello" 2>&1)
assert_contains "env has CLAUDE_CODE_OAUTH_TOKEN from file" "CLAUDE_CODE_OAUTH_TOKEN=file-token-456" "$out"
assert_not_contains "no credentials mount" ".credentials.json:ro" "$out"
teardown

echo "=== credentials file fallback ==="
setup
# credentials file exists (from setup), no token
out=$(bash "$UNDER_TEST" -p "hello" 2>&1)
assert_contains "mounts credentials file" ".credentials.json:ro" "$out"
assert_not_contains "no CLAUDE_CODE_OAUTH_TOKEN" "CLAUDE_CODE_OAUTH_TOKEN" "$out"
teardown

echo "=== no auth shows error ==="
setup
rm -f "$TEST_DIR/.claude/.credentials.json"
rc=0
out=$(bash "$UNDER_TEST" -p "hello" 2>&1) || rc=$?
assert_exit "exits non-zero" 1 "$rc"
assert_contains "error mentions setup" "claude-docker setup" "$out"
teardown

echo "=== env var takes priority over token file ==="
setup
rm -f "$TEST_DIR/.claude/.credentials.json"
echo "file-token-456" > "$TEST_DIR/.claude-docker/.oauth-token"
out=$(CLAUDE_CODE_OAUTH_TOKEN="env-token-789" bash "$UNDER_TEST" -p "hello" 2>&1)
assert_contains "uses env var token" "CLAUDE_CODE_OAUTH_TOKEN=env-token-789" "$out"
assert_not_contains "does not use file token" "file-token-456" "$out"
teardown

echo "=== cleanup trap calls container stop on signal ==="
setup
mkdir -p "$TEST_DIR/Documents/Notes"
# Replace stubs with ones that log stop calls and handle signals
expected_hash=$(current_build_hash)
write_rt_stubs "$(cat <<STUB
#!/usr/bin/env bash
if [[ "\${1:-}" == "image" && "\$*" == *"--format"* ]]; then echo "$expected_hash"; exit 0; fi
if [[ "\${1:-}" == "image" ]]; then exit 0; fi
if [[ "\${1:-}" == "stop" ]]; then echo "STOP_CALLED: \$2" >> "\$HOME/rt-stop.log"; exit 0; fi
# Simulate a long-running container; exit on INT/TERM like real runtime would
if [[ "\${1:-}" == "run" ]]; then
    trap 'exit 130' INT TERM
    echo "RT_ARGS: \$*" >> "$TEST_DIR/rt-args.log"
    sleep 60 &
    pid=\$!
    wait \$pid
    exit \$?
fi
STUB
)"
# Run claude-docker in background so we can send signal to it directly
timeout 3 bash "$UNDER_TEST" agent --no-stream notes > /dev/null 2>&1 || true
sleep 0.5
if [[ -f "$TEST_DIR/rt-stop.log" ]]; then
    stop_log=$(cat "$TEST_DIR/rt-stop.log")
    assert_contains "container stop called with container name" "claude-code-" "$stop_log"
else
    echo "  FAIL: container stop was never called"
    echo "  DEBUG: rt-args.log = $(cat "$TEST_DIR/rt-args.log" 2>/dev/null || echo 'NOT FOUND')"
    FAIL=$((FAIL + 1))
fi
teardown

echo "=== container-CLAUDE.md is copied to config dir ==="
setup
out=$(bash "$UNDER_TEST" -p "hello" 2>&1)
assert_eq "CLAUDE.md exists in config dir" "true" "$(test -f "$TEST_DIR/.claude-docker/CLAUDE.md" && echo true || echo false)"
assert_contains "CLAUDE.md has git guidance" "Git is not configured" "$(cat "$TEST_DIR/.claude-docker/CLAUDE.md")"
assert_contains "CLAUDE.md has no-commit guidance" "do NOT commit" "$(cat "$TEST_DIR/.claude-docker/CLAUDE.md")"
teardown

echo "=== .claude.json is auto-created when missing ==="
setup
# Remove any pre-existing .claude.json
rm -f "$TEST_DIR/.claude-docker/.claude.json"
out=$(bash "$UNDER_TEST" -p "hello" 2>&1)
assert_eq ".claude.json exists after run" "true" "$(test -f "$TEST_DIR/.claude-docker/.claude.json" && echo true || echo false)"
assert_eq ".claude.json contains empty object" "{}" "$(cat "$TEST_DIR/.claude-docker/.claude.json")"
assert_contains "mounts .claude.json" ".claude.json:/home/node/.claude.json" "$out"
teardown

echo "=== .claude.json is always mounted ==="
setup
echo '{"mcpServers":{}}' > "$TEST_DIR/.claude-docker/.claude.json"
out=$(bash "$UNDER_TEST" -p "hello" 2>&1)
assert_contains "mounts .claude.json" ".claude.json:/home/node/.claude.json" "$out"
teardown

echo "=== claude-docker.yaml is auto-created when missing ==="
setup
# Remove any pre-existing claude-docker.yaml
rm -f "$TEST_DIR/.claude-docker/claude-docker.yaml"
out=$(bash "$UNDER_TEST" -p "hello" 2>&1)
assert_eq "claude-docker.yaml exists after run" "true" "$(test -f "$TEST_DIR/.claude-docker/claude-docker.yaml" && echo true || echo false)"
assert_contains "contains streamLogging" "streamLogging" "$(cat "$TEST_DIR/.claude-docker/claude-docker.yaml")"
assert_contains "enabled is true" "enabled.*true" "$(cat "$TEST_DIR/.claude-docker/claude-docker.yaml")"
teardown

echo "=== claude-docker.yaml is always mounted ==="
setup
echo '{"mcpServers":{}, "streamLogging": {"enabled": true}}' > "$TEST_DIR/.claude-docker/claude-docker.yaml"
out=$(bash "$UNDER_TEST" -p "hello" 2>&1)
assert_contains "mounts claude-docker.yaml" "claude-docker.yaml:/home/node/claude-docker.yaml" "$out"
teardown

echo "=== setup-c3po requires two arguments ==="
setup
rc=0
out=$(bash "$UNDER_TEST" setup-c3po 2>&1) || rc=$?
assert_exit "exits non-zero" 1 "$rc"
assert_contains "shows usage" "url" "$out"
teardown

echo "=== setup-c3po with one argument fails ==="
setup
rc=0
out=$(bash "$UNDER_TEST" setup-c3po http://example.com 2>&1) || rc=$?
assert_exit "exits non-zero" 1 "$rc"
assert_contains "shows usage" "url" "$out"
teardown

echo "=== shell subcommand runs interactive container ==="
setup
# Replace stubs with ones that just print args and exit immediately
expected_hash=$(current_build_hash)
write_rt_stubs "$(cat <<STUB
#!/usr/bin/env bash
if [[ "\${1:-}" == "image" && "\$*" == *"--format"* ]]; then echo "$expected_hash"; exit 0; fi
if [[ "\${1:-}" == "image" ]]; then exit 0; fi
if [[ "\${1:-}" == "stop" ]]; then exit 0; fi
echo "RT_ARGS: \$*"
exit 0
STUB
)"
out=$(echo "" | bash "$UNDER_TEST" shell 2>&1)
assert_contains "uses --entrypoint bash" "--entrypoint bash" "$out"
assert_contains "uses -it" "-it" "$out"
assert_contains "mounts .claude.json" ".claude.json:/home/node/.claude.json" "$out"
assert_contains "mounts claude-docker.yaml" "claude-docker.yaml:/home/node/claude-docker.yaml" "$out"
teardown

echo "=== help shows setup-c3po ==="
setup
out=$(bash "$UNDER_TEST" -h 2>&1)
assert_contains "shows setup-c3po" "setup-c3po" "$out"
assert_contains "shows shell" "shell" "$out"
teardown

# --- auto-rebuild tests ---

echo "=== stale image triggers rebuild ==="
setup
# Override stubs to return a stale hash
write_rt_stubs '#!/usr/bin/env bash
if [[ "${1:-}" == "image" && "$*" == *"--format"* ]]; then echo "stale-hash-000"; exit 0; fi
if [[ "${1:-}" == "image" ]]; then exit 0; fi
if [[ "${1:-}" == "stop" ]]; then exit 0; fi
if [[ "${1:-}" == "build" ]]; then echo "RT_BUILD: $*"; exit 0; fi
echo "RT_ARGS: $*"'
out=$(bash "$UNDER_TEST" -p "hello" 2>&1)
assert_contains "triggers build" "RT_BUILD:" "$out"
assert_contains "build includes --label" "--label" "$out"
assert_contains "build includes build.hash" "build.hash=" "$out"
teardown

echo "=== fresh image skips rebuild ==="
setup
# Default stub already returns the correct hash
# Override stubs to log build calls so we can verify build is NOT called
expected_hash=$(current_build_hash)
write_rt_stubs "$(cat <<STUB
#!/usr/bin/env bash
if [[ "\${1:-}" == "image" && "\$*" == *"--format"* ]]; then echo "$expected_hash"; exit 0; fi
if [[ "\${1:-}" == "image" ]]; then exit 0; fi
if [[ "\${1:-}" == "stop" ]]; then exit 0; fi
if [[ "\${1:-}" == "build" ]]; then echo "RT_BUILD: \$*"; exit 0; fi
echo "RT_ARGS: \$*"
STUB
)"
out=$(bash "$UNDER_TEST" -p "hello" 2>&1)
assert_not_contains "no build triggered" "RT_BUILD:" "$out"
teardown

echo "=== missing image triggers rebuild ==="
setup
# Override stubs: image inspect fails (image doesn't exist)
write_rt_stubs '#!/usr/bin/env bash
if [[ "${1:-}" == "image" ]]; then exit 1; fi
if [[ "${1:-}" == "stop" ]]; then exit 0; fi
if [[ "${1:-}" == "build" ]]; then echo "RT_BUILD: $*"; exit 0; fi
echo "RT_ARGS: $*"'
out=$(bash "$UNDER_TEST" -p "hello" 2>&1)
assert_contains "triggers build" "RT_BUILD:" "$out"
teardown

echo "=== -b flag always rebuilds even with matching hash ==="
setup
# Default stub returns matching hash, but -b should force rebuild
expected_hash=$(current_build_hash)
write_rt_stubs "$(cat <<STUB
#!/usr/bin/env bash
if [[ "\${1:-}" == "image" && "\$*" == *"--format"* ]]; then echo "$expected_hash"; exit 0; fi
if [[ "\${1:-}" == "image" ]]; then exit 0; fi
if [[ "\${1:-}" == "stop" ]]; then exit 0; fi
if [[ "\${1:-}" == "build" ]]; then echo "RT_BUILD: \$*"; exit 0; fi
echo "RT_ARGS: \$*"
STUB
)"
out=$(bash "$UNDER_TEST" -b -p "hello" 2>&1)
assert_contains "build triggered with -b" "RT_BUILD:" "$out"
assert_contains "build includes --label" "--label" "$out"
teardown

echo "=== build passes correct hash label ==="
setup
write_rt_stubs '#!/usr/bin/env bash
if [[ "${1:-}" == "image" && "$*" == *"--format"* ]]; then echo "stale-hash-000"; exit 0; fi
if [[ "${1:-}" == "image" ]]; then exit 0; fi
if [[ "${1:-}" == "stop" ]]; then exit 0; fi
if [[ "${1:-}" == "build" ]]; then echo "RT_BUILD: $*"; exit 0; fi
echo "RT_ARGS: $*"'
out=$(bash "$UNDER_TEST" -p "hello" 2>&1)
expected_hash=$(current_build_hash)
assert_contains "build label has correct hash" "build.hash=$expected_hash" "$out"
teardown

# --- entrypoint.sh tests ---

ENTRYPOINT="$SCRIPT_DIR/entrypoint.sh"

# Helper to set up entrypoint test environment with mock claude
entrypoint_setup() {
    TEST_DIR=$(mktemp -d)
    export HOME="$TEST_DIR"
    mkdir -p "$TEST_DIR/.claude"
    # Mock claude that logs its arguments
    cat > "$TEST_DIR/claude" <<'STUB'
#!/usr/bin/env bash
echo "CLAUDE_ARGS: $*"
STUB
    chmod +x "$TEST_DIR/claude"
    export PATH="$TEST_DIR:$PATH"
}

echo "=== entrypoint: no plugins dir skips updates ==="
entrypoint_setup
out=$("$ENTRYPOINT" -p "hello" 2>&1)
assert_contains "calls claude with passthrough args" "CLAUDE_ARGS: --dangerously-skip-permissions -p hello" "$out"
assert_not_contains "no updating message" "Updating plugins" "$out"
teardown

echo "=== entrypoint: with plugins calls marketplace and plugin update ==="
entrypoint_setup
mkdir -p "$TEST_DIR/.claude/plugins/c3po@michaelansel"
out=$("$ENTRYPOINT" -p "hello" 2>&1)
assert_contains "updating message" "Updating plugins" "$out"
assert_contains "calls claude" "CLAUDE_ARGS: --dangerously-skip-permissions -p hello" "$out"
teardown

echo "=== entrypoint: plugin update failure still launches claude ==="
entrypoint_setup
mkdir -p "$TEST_DIR/.claude/plugins/c3po@michaelansel"
# Make claude fail for plugin commands but succeed for the final exec
cat > "$TEST_DIR/claude" <<'STUB'
#!/usr/bin/env bash
if [[ "${1:-}" == "plugin" ]]; then exit 1; fi
echo "CLAUDE_ARGS: $*"
STUB
chmod +x "$TEST_DIR/claude"
rc=0
out=$("$ENTRYPOINT" -p "hello" 2>&1) || rc=$?
assert_exit "exits zero despite plugin failures" 0 "$rc"
assert_contains "calls claude" "CLAUDE_ARGS: --dangerously-skip-permissions -p hello" "$out"
teardown

echo "=== entrypoint: marketplace dedup with two plugins from same marketplace ==="
entrypoint_setup
mkdir -p "$TEST_DIR/.claude/plugins/c3po@michaelansel"
mkdir -p "$TEST_DIR/.claude/plugins/other@michaelansel"
# Track claude calls
cat > "$TEST_DIR/claude" <<'STUB'
#!/usr/bin/env bash
if [[ "${1:-}" == "plugin" && "${2:-}" == "marketplace" ]]; then
    echo "MARKETPLACE_UPDATE: $*" >> "$HOME/claude-calls.log"
    exit 0
fi
if [[ "${1:-}" == "plugin" && "${2:-}" == "update" ]]; then
    echo "PLUGIN_UPDATE: $*" >> "$HOME/claude-calls.log"
    exit 0
fi
echo "CLAUDE_ARGS: $*"
STUB
chmod +x "$TEST_DIR/claude"
out=$("$ENTRYPOINT" -p "hello" 2>&1)
mp_count=$(grep -c "MARKETPLACE_UPDATE" "$TEST_DIR/claude-calls.log" 2>/dev/null || echo 0)
plugin_count=$(grep -c "PLUGIN_UPDATE" "$TEST_DIR/claude-calls.log" 2>/dev/null || echo 0)
assert_eq "one marketplace update call" "1" "$mp_count"
assert_eq "two plugin update calls" "2" "$plugin_count"
teardown

echo "=== entrypoint: c3po creds valid (200) launches claude ==="
entrypoint_setup
export CLAUDE_AGENT_MODE=1
cat > "$TEST_DIR/.claude/c3po-credentials.json" <<'JSON'
{"coordinator_url": "http://localhost:9999", "api_token": "test-token"}
JSON
# Mock jq
cat > "$TEST_DIR/jq" <<'STUB'
#!/usr/bin/env bash
if [[ "$1" == "-r" && "$2" == ".coordinator_url" ]]; then echo "http://localhost:9999"; exit 0; fi
if [[ "$1" == "-r" && "$2" == ".api_token" ]]; then echo "test-token"; exit 0; fi
if [[ "$1" == "-r" && "$2" == '.machine_name // "docker"' ]]; then echo "docker"; exit 0; fi
STUB
chmod +x "$TEST_DIR/jq"
# Mock curl returning 200
cat > "$TEST_DIR/curl" <<'STUB'
#!/usr/bin/env bash
echo "200"
STUB
chmod +x "$TEST_DIR/curl"
rc=0
out=$("$ENTRYPOINT" -p "hello" 2>&1) || rc=$?
assert_exit "exits zero" 0 "$rc"
assert_contains "checks credentials" "Checking c3po credentials" "$out"
assert_contains "calls claude" "CLAUDE_ARGS: --dangerously-skip-permissions -p hello" "$out"
unset CLAUDE_AGENT_MODE
teardown

echo "=== entrypoint: c3po creds invalid (401) exits 1 ==="
entrypoint_setup
export CLAUDE_AGENT_MODE=1
cat > "$TEST_DIR/.claude/c3po-credentials.json" <<'JSON'
{"coordinator_url": "http://localhost:9999", "api_token": "bad-token"}
JSON
cat > "$TEST_DIR/jq" <<'STUB'
#!/usr/bin/env bash
if [[ "$1" == "-r" && "$2" == ".coordinator_url" ]]; then echo "http://localhost:9999"; exit 0; fi
if [[ "$1" == "-r" && "$2" == ".api_token" ]]; then echo "bad-token"; exit 0; fi
if [[ "$1" == "-r" && "$2" == '.machine_name // "docker"' ]]; then echo "docker"; exit 0; fi
STUB
chmod +x "$TEST_DIR/jq"
cat > "$TEST_DIR/curl" <<'STUB'
#!/usr/bin/env bash
echo "401"
STUB
chmod +x "$TEST_DIR/curl"
rc=0
out=$("$ENTRYPOINT" -p "hello" 2>&1) || rc=$?
assert_exit "exits non-zero" 1 "$rc"
assert_contains "invalid credentials error" "HTTP 401" "$out"
unset CLAUDE_AGENT_MODE
teardown

echo "=== entrypoint: c3po pattern mismatch (403) exits 1 ==="
entrypoint_setup
export CLAUDE_AGENT_MODE=1
cat > "$TEST_DIR/.claude/c3po-credentials.json" <<'JSON'
{"coordinator_url": "http://localhost:9999", "api_token": "test-token"}
JSON
cat > "$TEST_DIR/jq" <<'STUB'
#!/usr/bin/env bash
if [[ "$1" == "-r" && "$2" == ".coordinator_url" ]]; then echo "http://localhost:9999"; exit 0; fi
if [[ "$1" == "-r" && "$2" == ".api_token" ]]; then echo "test-token"; exit 0; fi
if [[ "$1" == "-r" && "$2" == '.machine_name // "docker"' ]]; then echo "docker"; exit 0; fi
STUB
chmod +x "$TEST_DIR/jq"
cat > "$TEST_DIR/curl" <<'STUB'
#!/usr/bin/env bash
echo "403"
STUB
chmod +x "$TEST_DIR/curl"
rc=0
out=$("$ENTRYPOINT" -p "hello" 2>&1) || rc=$?
assert_exit "exits non-zero" 1 "$rc"
assert_contains "pattern mismatch error" "does not authorize docker agents" "$out"
unset CLAUDE_AGENT_MODE
teardown

echo "=== entrypoint: c3po unreachable (000) exits 1 ==="
entrypoint_setup
export CLAUDE_AGENT_MODE=1
cat > "$TEST_DIR/.claude/c3po-credentials.json" <<'JSON'
{"coordinator_url": "http://localhost:9999", "api_token": "test-token"}
JSON
cat > "$TEST_DIR/jq" <<'STUB'
#!/usr/bin/env bash
if [[ "$1" == "-r" && "$2" == ".coordinator_url" ]]; then echo "http://localhost:9999"; exit 0; fi
if [[ "$1" == "-r" && "$2" == ".api_token" ]]; then echo "test-token"; exit 0; fi
if [[ "$1" == "-r" && "$2" == '.machine_name // "docker"' ]]; then echo "docker"; exit 0; fi
STUB
chmod +x "$TEST_DIR/jq"
cat > "$TEST_DIR/curl" <<'STUB'
#!/usr/bin/env bash
echo "000"
STUB
chmod +x "$TEST_DIR/curl"
rc=0
out=$("$ENTRYPOINT" -p "hello" 2>&1) || rc=$?
assert_exit "exits non-zero" 1 "$rc"
assert_contains "unreachable error" "could not reach c3po coordinator" "$out"
unset CLAUDE_AGENT_MODE
teardown

echo "=== entrypoint: no creds file in agent mode exits 1 ==="
entrypoint_setup
export CLAUDE_AGENT_MODE=1
rc=0
out=$("$ENTRYPOINT" -p "hello" 2>&1) || rc=$?
assert_exit "exits non-zero" 1 "$rc"
assert_contains "missing creds error" "Run setup-c3po first" "$out"
unset CLAUDE_AGENT_MODE
teardown

echo "=== entrypoint: non-agent mode skips creds check ==="
entrypoint_setup
# No creds file, no CLAUDE_AGENT_MODE — should succeed
rc=0
out=$("$ENTRYPOINT" -p "hello" 2>&1) || rc=$?
assert_exit "exits zero" 0 "$rc"
assert_contains "calls claude" "CLAUDE_ARGS: --dangerously-skip-permissions -p hello" "$out"
assert_not_contains "no creds check" "Checking c3po credentials" "$out"
teardown

echo "=== block format agent with model ==="
setup
# Write a mixed agents.yaml with block format
cat > "$TEST_DIR/.claude-docker/agents.yaml" <<'YAML'
notes: ~/Documents/Notes
coder:
  workspace: ~/Code/project
  model: opus
YAML
mkdir -p "$TEST_DIR/Code/project"
out=$(bash "$UNDER_TEST" agent --no-stream coder 2>&1)
assert_contains "workspace resolves" "/Code/project" "$out"
assert_contains "model flag passed" "--model opus" "$out"
assert_contains "prompt is /c3po auto" "/c3po auto" "$out"
teardown

echo "=== block format agent without model ==="
setup
cat > "$TEST_DIR/.claude-docker/agents.yaml" <<'YAML'
builder:
  workspace: ~/Build
YAML
mkdir -p "$TEST_DIR/Build"
out=$(bash "$UNDER_TEST" agent --no-stream builder 2>&1)
assert_contains "workspace resolves" "/Build" "$out"
assert_not_contains "no model flag" "--model" "$out"
teardown

echo "=== block format missing workspace exits non-zero ==="
setup
cat > "$TEST_DIR/.claude-docker/agents.yaml" <<'YAML'
broken:
  model: opus
YAML
rc=0
out=$(bash "$UNDER_TEST" agent broken 2>&1) || rc=$?
assert_exit "exits non-zero" 1 "$rc"
assert_contains "error about workspace" "no workspace" "$out"
teardown

echo "=== agent list with mixed formats ==="
setup
cat > "$TEST_DIR/.claude-docker/agents.yaml" <<'YAML'
notes: ~/Documents/Notes
coder:
  workspace: ~/Code/project
  model: opus
builder:
  workspace: ~/Build
YAML
out=$(bash "$UNDER_TEST" agent list 2>&1)
assert_contains "shows notes" "notes" "$out"
assert_contains "shows notes dir" "~/Documents/Notes" "$out"
assert_contains "shows coder" "coder" "$out"
assert_contains "shows coder dir" "~/Code/project" "$out"
assert_contains "shows coder model" "(model: opus)" "$out"
assert_contains "shows builder" "builder" "$out"
assert_contains "shows builder dir" "~/Build" "$out"
assert_not_contains "builder has no model annotation" "builder.*model" "$out"
teardown

echo "=== simple format has no --model flag ==="
setup
mkdir -p "$TEST_DIR/Documents/Notes"
out=$(bash "$UNDER_TEST" agent --no-stream notes 2>&1)
assert_not_contains "no model flag for simple agent" "--model" "$out"
teardown

echo "=== mixed format ordering — block between simple entries ==="
setup
cat > "$TEST_DIR/.claude-docker/agents.yaml" <<'YAML'
first: ~/First
middle:
  workspace: ~/Middle
  model: sonnet
last: ~/Last
YAML
mkdir -p "$TEST_DIR/First" "$TEST_DIR/Middle" "$TEST_DIR/Last"
out_first=$(bash "$UNDER_TEST" --no-stream agent first 2>&1)
assert_contains "first agent resolves" "/First" "$out_first"
assert_not_contains "first has no model" "--model" "$out_first"
out_middle=$(bash "$UNDER_TEST" --no-stream agent middle 2>&1)
assert_contains "middle agent resolves" "/Middle" "$out_middle"
assert_contains "middle has model" "--model sonnet" "$out_middle"
out_last=$(bash "$UNDER_TEST" --no-stream agent last 2>&1)
assert_contains "last agent resolves" "/Last" "$out_last"
assert_not_contains "last has no model" "--model" "$out_last"
teardown

echo "=== agent mode passes CLAUDE_AGENT_MODE=1 ==="
setup
mkdir -p "$TEST_DIR/Documents/Notes"
out=$(bash "$UNDER_TEST" agent --no-stream notes 2>&1)
assert_contains "env has CLAUDE_AGENT_MODE=1" "CLAUDE_AGENT_MODE=1" "$out"
teardown

echo "=== direct mode does not pass CLAUDE_AGENT_MODE ==="
setup
out=$(bash "$UNDER_TEST" -p "hello" 2>&1)
assert_not_contains "no CLAUDE_AGENT_MODE" "CLAUDE_AGENT_MODE" "$out"
teardown

echo "=== clean-logs command exists ==="
setup
out=$(bash "$UNDER_TEST" clean-logs 2>&1)
assert_contains "shows usage" "older-than" "$out"
teardown

echo "=== clean-logs with invalid --older-than fails ==="
setup
rc=0
out=$(bash "$UNDER_TEST" clean-logs --older-than "invalid" 2>&1) || rc=$?
assert_exit "exits non-zero" 1 "$rc"
teardown

echo "=== clean-logs with valid --older-than cleans files ==="
setup
# Create some test log files
mkdir -p "$TEST_DIR/.claude-docker/session-logs"
echo '{}' > "$TEST_DIR/.claude-docker/session-logs/test1.json"
echo '{}' > "$TEST_DIR/.claude-docker/session-logs/test2.json"
# Create a more recent file that should not be deleted
echo '{}' > "$TEST_DIR/.claude-docker/session-logs/recent.json"
# Modify recent file to be newer
touch -t 202501011200 "$TEST_DIR/.claude-docker/session-logs/recent.json"
# Modify old files to be older
touch -t 202401011200 "$TEST_DIR/.claude-docker/session-logs/test1.json"
touch -t 202401011200 "$TEST_DIR/.claude-docker/session-logs/test2.json"
out=$(bash "$UNDER_TEST" clean-logs --older-than "365d" 2>&1)
assert_contains "cleans old files" "Cleaned up 2 log file(s)" "$out"
# Verify old files are deleted but recent remains
assert_not_contains "recent file deleted" "recent.json" "$out"
teardown

echo "=== claude-docker.yaml contains streamLogging config ==="
setup
# Remove any pre-existing claude-docker.yaml
rm -f "$TEST_DIR/.claude-docker/claude-docker.yaml"
out=$(bash "$UNDER_TEST" -p "hello" 2>&1)
assert_eq ".claude-docker.yaml exists after run" "true" "$(test -f "$TEST_DIR/.claude-docker/claude-docker.yaml" && echo true || echo false)"
assert_contains "contains streamLogging" "streamLogging" "$(cat "$TEST_DIR/.claude-docker/claude-docker.yaml")"
assert_contains "enabled is true" "enabled.*true" "$(cat "$TEST_DIR/.claude-docker/claude-docker.yaml")"
teardown

echo "=== clean-logs respects config retentionDays ==="
setup
# Remove any pre-existing claude-docker.yaml
rm -f "$TEST_DIR/.claude-docker/claude-docker.yaml"
# Create config with 7 day retention
mkdir -p "$TEST_DIR/.claude-docker"
cat > "$TEST_DIR/.claude-docker/claude-docker.yaml" <<'YAML'
streamLogging:
  enabled: true
  directory: ~/.claude-docker/session-logs
  retentionDays: 7
YAML
# Create some test log files
mkdir -p "$TEST_DIR/.claude-docker/session-logs"
echo '{}' > "$TEST_DIR/.claude-docker/session-logs/test1.json"
echo '{}' > "$TEST_DIR/.claude-docker/session-logs/test2.json"
# Modify files to be older than 7 days
touch -t 202501011200 "$TEST_DIR/.claude-docker/session-logs/test1.json"
touch -t 202501011200 "$TEST_DIR/.claude-docker/session-logs/test2.json"
out=$(bash "$UNDER_TEST" clean-logs 2>&1)
assert_contains "cleans old files" "Cleaned up 2 log file(s)" "$out"
teardown

# --- cleanup stray test artifacts ---
rm -f "$SCRIPT_DIR/format-stream.test-bak"

# --- summary ---
echo ""
echo "Results: $PASS passed, $FAIL failed"
if [[ $FAIL -gt 0 ]]; then
    exit 1
fi
